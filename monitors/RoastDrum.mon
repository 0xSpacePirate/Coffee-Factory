using com.apama.correlator.Component;

event ColorTrack{
	float currentBeanVolt;
}

event DrumTemperature{
	float currentDrumTemperature;
}

monitor RoastDrum {
	
	integer beanIllustrator := 1; //parses the number so the program can display the actual color of the bean in a range from 1 to 100; Where 1 is green and very black is 100;
	integer currentBeanTemp := 0; // average temp;

	float currentDrumTemp; // default temp in drum before roasting is just below 200, e.g. 190;
	float currentBeanVolt := BeanColorVolt.MAXIMUM; 
	
	boolean highRoastTemp := false; // used as a gate to decrease the temp;
	boolean lowRoastTemp := true; // used as a gate to increase the temp;
	
	action onload() {
		log Message.LOADED_ROAST at INFO;
		initialize();
	}

	action initialize(){
		updateVariables();
		heatDrum();
		colorTrack();
	}
		
	/** 
		...
	*/
	action heatDrum(){		
		listener listen := on all wait (Delay.TWO_SECONDS){
			float randomTemp := (BeanRandom.TEMP_INCREMENTER).rand();	
			if checkTempIfTooHigh() {
				//randomTemp := -randomTemp;
				terminateHeatIfTooLow(listen);
			}			
			
			Component.setUserStatus(UserStatus.DRUM, currentDrumTemp.toString());			
		}
	}	
	
	action terminateHeatIfTooLow(listener listen){
		if currentDrumTemp <= Temperature.DRUM_MINIMUM {
			//lowRoastTemp := true;
			//highRoastTemp := false;
			listen.quit();
		}
	}
	
	/** 
	@return ...
	*/
	action checkTempIfTooHigh() returns boolean{
		if currentDrumTemp >= Temperature.IMMINENT_FIRE {
			highRoastTemp := true;
			lowRoastTemp := false;
		}
		return highRoastTemp;
	}
		
	/** 
		....
	*/
	action colorTrack(){		
		listener listen := on all wait (Delay.ONE_SECOND){
			float randomVoltIncrease := (BeanTracker.COLOR_CHANGER).rand(); // the beans spin while in the drum, therefore their temperature might differ slightly. Plus, making the graph more realistic;
			float gate := (BeanRandom.GATE_BOUND).rand();
			integer beanColorIllustrator := getBeanIllustrator(currentBeanVolt);
			
			Component.setUserStatus(UserStatus.BEAN_COLOR, currentBeanVolt.toString());
			Component.setUserStatus(UserStatus.BEAN_ILLUSTRATOR, beanColorIllustrator.toString());
			
			if currentBeanVolt <= BeanColorVolt.MINIMUM {
				listen.quit();
			}
		}
	}
	
	action updateVariables(){
		monitor.subscribe(Channel.ROAST);
		updateTemp();
		updateColorTrack();
	}
	
	action updateTemp(){
		on all DrumTemperature() as dt{
			currentDrumTemp := dt.currentDrumTemperature;
		}
	}
	
	action updateColorTrack(){
		on all ColorTrack() as ct{
			
			currentBeanVolt := ct.currentBeanVolt;
		}
	}
	
	/** 
	@param beanVolt ...
	@return ....
		formula: the color scheme graph contains half the range the beanvolt has
		(i.e. BeanVolt starts at 100 and goes down to 0, colorScheme starts at 0 and goes up to 50).
		Hence, get half of bean volt and remove 50 since the colorScheme operates in the 0-50 range;
	*/
	action getBeanIllustrator(float beanVolt) returns integer {
		return (getHalf(beanVolt) - ColorScheme.SIZE).abs(); 
	}
	
	action getHalf(float value) returns integer{
		return value.floor() / Divider.BY_HALF;
	}
	
}
