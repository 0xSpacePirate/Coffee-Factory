VERS 00000001 5
HEAD 00001306 <?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="/resources/transform.xslt"?><header><componentName>correlator</componentName><version>10.5.0.0.357639</version><build>rel/10.5.0.x@357639</build><buildPlatform>amd64-win</buildPlatform><platform>Windows 10 Enterprise</platform><cputype>GenuineIntel family 6 model 14 stepping 3 Intel(R) Core(TM) i7-6600U CPU @ 2.60GHz</cputype><cpus name="cpus">4.00</cpus><javaEnabled>true</javaEnabled><replayLogMode>inputLog</replayLogMode><args><arg>C:\dev\apama_win_full_latest\Apama\bin\correlator.exe</arg><arg>--config</arg><arg>C:\Users\y508970\workspace105\Coffee Factory\config\CorrelatorConfig.yaml</arg><arg>--port</arg><arg>15903</arg><arg>--loglevel</arg><arg>INFO</arg><arg>--name</arg><arg>Apama Designer Correlator for Coffee Factory(Coffee Factory:defaultCorrelator)</arg><arg>-j</arg><arg>--inputLog</arg><arg>logs/defaultCorrelator_${START_TIME}_${ID}.input.log</arg></args><environment><variable>ALLUSERSPROFILE=C:\ProgramData</variable><variable>APAMA_HOME=C:\dev\apama_win_full_latest\Apama</variable><variable>APAMA_WORK=C:\Users\Public\SoftwareAG\ApamaWork_10.5</variable><variable>APPDATA=C:\Users\y508970\AppData\Roaming</variable><variable>COMMONPROGRAMFILES=C:\Program Files\Common Files</variable><variable>COMMONPROGRAMFILES(X86)=C:\Program Files (x86)\Common Files</variable><variable>COMMONPROGRAMW6432=C:\Program Files\Common Files</variable><variable>COMPUTERNAME=SAG-98V9PF2</variable><variable>COMSPEC=C:\Windows\system32\cmd.exe</variable><variable>DEFLOGDIR=C:\ProgramData\McAfee\Endpoint Security\Logs</variable><variable>DRIVERDATA=C:\Windows\System32\Drivers\DriverData</variable><variable>EMPIRUMSERVER=cukuni02.eur.ad.sag</variable><variable>EMPIRUMSERVICEPARTITION=0</variable><variable>EMPSRVLONG=cukuni02.eur.ad.sag</variable><variable>HOMEDRIVE=C:</variable><variable>HOMEPATH=\Users\y508970</variable><variable>LOCALAPPDATA=C:\Users\y508970\AppData\Local</variable><variable>LOGONSERVER=\\CUKDC85</variable><variable>NUMBER_OF_PROCESSORS=4</variable><variable>ONEDRIVE=C:\Users\y508970\OneDrive - Software AG</variable><variable>ONEDRIVECOMMERCIAL=C:\Users\y508970\OneDrive - Software AG</variable><variable>OS=Windows_NT</variable><variable>PATH=C:\dev\apama_win_full_latest\Apama\..\jvm\jvm\jre\bin\server;C:\dev\apama_win_full_latest\Apama\..\jvm\jvm\jre\bin;C:\dev\apama_win_full_latest\Apama\bin;C:\dev\apama_win_full_latest\Apama\..\common\security\openssl\bin;C:\Users\Public\SoftwareAG\ApamaWork_10.5\lib;C:\dev\apama_win_full_latest\Apama\..\jvm\jvm\jre\bin;C:\dev\apama_win_full_latest\Apama\..\jvm\jvm\jre\bin\server;C:\dev\apama_win_full_latest\Apama\..\UniversalMessaging\cplus\lib\x86_64;C:\dev\apama_win_full_latest\Apama\bin;C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;C:\Windows\System32\OpenSSH\;C:\Program Files\Intel\WiFi\bin\;C:\Program Files\Common Files\Intel\WirelessCommon\;C:\Program Files (x86)\Intel\Intel(R) Management Engine Components\DAL;C:\Program Files\Intel\Intel(R) Management Engine Components\DAL;C:\Program Files\PuTTY\;C:\Program Files\SlikSvn\bin;C:\Program Files\dotnet\;C:\Program Files\Microsoft SQL Server\130\Tools\Binn\;C:\Program Files\TortoiseSVN\bin;C:\Program Files\TortoiseGit\bin;C:\Users\y508970\AppData\Local\Microsoft\WindowsApps;C:\Users\y508970\AppData\Local\Programs\Git\cmd;C:\Users\y508970\AppData\Local\GitHubDesktop\bin</variable><variable>PATHEXT=.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC</variable><variable>PROCESSOR_ARCHITECTURE=AMD64</variable><variable>PROCESSOR_IDENTIFIER=Intel64 Family 6 Model 78 Stepping 3, GenuineIntel</variable><variable>PROCESSOR_LEVEL=6</variable><variable>PROCESSOR_REVISION=4e03</variable><variable>PROGRAMDATA=C:\ProgramData</variable><variable>PROGRAMFILES=C:\Program Files</variable><variable>PROGRAMFILES(X86)=C:\Program Files (x86)</variable><variable>PROGRAMW6432=C:\Program Files</variable><variable>PROMPT=$P$G</variable><variable>PSMODULEPATH=C:\Program Files\WindowsPowerShell\Modules;C:\Windows\system32\WindowsPowerShell\v1.0\Modules;C:\Program Files\Barracuda\Network Access Client\Modules</variable><variable>PUBLIC=C:\Users\Public</variable><variable>SESSIONNAME=Console</variable><variable>SSL_CERT_FILE=C:\dev\apama_win_full_latest\Apama\..\common\security\openssl\cert.pem</variable><variable>SYSTEMDRIVE=C:</variable><variable>SYSTEMROOT=C:\Windows</variable><variable>TEMP=C:\Users\y508970\AppData\Local\Temp</variable><variable>TMP=C:\Users\y508970\AppData\Local\Temp</variable><variable>USERDNSDOMAIN=EUR.AD.SAG</variable><variable>USERDOMAIN=EUR</variable><variable>USERDOMAIN_ROAMINGPROFILE=EUR</variable><variable>USERNAME=y508970</variable><variable>USERPROFILE=C:\Users\y508970</variable><variable>WINDIR=C:\Windows</variable></environment><version>10.5.0.0.357639</version></header>
YAML 000005a1 ###############################################################################
# $Copyright (c) 2016 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.$
# Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG
###############################################################################

#To set the default log file and level for an EPL package, monitor, or event, specify
# logging details in the eplLogging section of the YAML configuration file.
#For example:
#eplLogging:
#  com.myCompany.Client:
#    file: apama/Client.log
#    level: DEBUG
#  com.myCompany.Internal: { level: ERROR }

engineConnect:
    - sourceHost: localhost
      sourcePort: 15904

      channels:
        - roastChannel
        - extractorChannel
        - freezeChannel
        - freezeDryerChannel

      mode: parallel
      disconnectIfSlow: true

#See the information on setting log files and log levels in a YAML configuration file in the documentation for more
# information about the supported options.
#To enable use of this file when you launch this project from Designer, edit the project's run/launch configuration,
#open the correlator, and tick the "Configuration" checkbox next to the textbox that names this .yaml file.
 00000049 C:\Users\y508970\workspace105\Coffee Factory\config\CorrelatorConfig.yaml
RAND 00000009 464021672
TIME 00000010 1568127087.206,1
CONN 0000003c 6735054542793918816:6734773080702110048 from 127.0.0.1:53492
CONN 0000003c 6735054529883851104:6733647180770101600 from 127.0.0.1:15904
TIME 0000000e 1568127087.6,1
CONN 0000003c 1907214234774601728:1992969454253309952 from 127.0.0.1:53484
TIME 0000000e 1568127087.8,1
MONF 00000b40 /**
 * $Copyright (c) 2016-2017 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.$
 * Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG
 */

package com.softwareag.connectivity.control;

/**
 * Used for com.softwareag.connectivity.Chain#ackUpTo() and
 * com.softwareag.connectivity.control.AckRequired#ackUpTo() , sent to the
 * control channel of the chain.
 * @private
 */
event AckUpTo {
	string messageId;
}

/**
 * Request from a connectivity chain to the application, asking it to reliably
 * acknowledge all events that came from the chain immediately prior to this
 * AckRequired.
 *
 * This event will be sent to the default channel of that chain. That is, your
 * EPL will not normally need to subscribe to any extra channels to receive
 * these requests, if it is already receiving regular events from that chain.
 *
 * A reliable-messaging-aware transport will issue these requests with as large
 * an interval as it can get away with, based on the constraints of the
 * external messaging system. So if your application has a "commit" mechanism
 * that has a large fixed cost (for example, a filesystem sync, a database
 * commit or an expensive computation) then doing a commit and acknowledgment
 * on and only on AckRequired requests makes sense.
 *
 * Do not rely on these requests being high frequency or timely; the functional
 * behaviour of your application should not depend on them, especially if
 * latency is important. Only the operations required for safely preserving the
 * effect of incoming events should be tied to AckRequired requests.
 *
 * @see com.softwareag.connectivity.Chain#ackUpTo() Otherwise, you can use this
 * action to perform per-event acknowledgments if the message id of each
 * incoming event is available.
 */
event AckRequired {
	/** The message id of the regular event received immediately before this AckRequired. */
	string messageId;

	/** Id of the connectivity chain that this request has come from. */
	string chainId;

	/**
	 * Acknowledge all previously received events from the connectivity chain
	 * as having been reliably processed by your application.
	 */
	action ackUpTo() {
		send AckUpTo(messageId) to "com.softwareag.connectivity.chaincontrol." + chainId;
	}
}

/**
 * Used by com.softwareag.connectivity.Chain#flush(). This event gets sent to
 * the control channel of the chain.
 * @private
 */
event Flush {
	integer requestId;
	context replyTo;
}

/**
 * Response to a flush request.
 *
 * @see com.softwareag.connectivity.Chain#flush()
 */
event FlushAck {
	/** Identifies the corresponding flush request. */
	integer requestId;
}
 0000004a C:\dev\apama_win_full_latest\Apama\monitors\ConnectivityPluginsControl.mon
MONF 000021ea /**
 * $Copyright (c) 2015-2018 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.$
 * Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG
 */

package com.softwareag.connectivity;

/**
 * Represents a chain instance and provides methods to perform various operations on it.
 */
event Chain
{
	/** @private */
	import "ConnectivityPlugin" as _plugin;
	/** 
	 * Destroy this chain instance. Chains that are managed by a dynamic chain
	 * manager cannot be destroyed this way.
	 * This should be called only once.
	 */
	action destroy()
	{
		_plugin.destroyChain(chain);
	}
	
	/**
	 * Return the unique id of the chain instance.
	 *
	 * @return The id of the chain instance
	 */
	action getId() returns string
	{
		return _plugin.getChainId(chain);
	}

	/**
	 * Acknowledge that a specific event and all previous events received from
	 * this connectivity chain have been reliably processed by your
	 * application.
	 *
	 * If you are going to make use of this action, then the message id of the
	 * incoming events will need to be available somehow. For example, as a
	 * field on the event.
	 *
	 * This action will only have an effect on chains with a
	 * reliable-messaging-aware transport, and should not be used otherwise.
	 *
	 * @see com.softwareag.connectivity.control.AckRequired  In some situations
	 * it may make more sense to do acknowledgments on AckRequired requests,
	 * rather than against events of the application's choice.
	 *
	 * @param messageId The message id of the specific event
	 */
	action ackUpTo(string messageId) {
		send control.AckUpTo(messageId) to "com.softwareag.connectivity.chaincontrol." + getId();
	}

	/**
	 * Ask the chain to acknowledge all events previously sent to it by the
	 * application. A FlushAck reply will be sent to the current context once
	 * these events have been reliably processed by the external system.
	 *
	 * This action will only have an effect on chains with a
	 * reliable-messaging-aware transport, and should not be used otherwise.
	 *
	 * A transport will still handle events that are sent to it, whether or not
	 * flushing is used. A flush request is purely a signalling mechanism.
	 *
	 * @see com.softwareag.connectivity.control.FlushAck
	 * @return The requestId of the expected FlushAck
	 */
	action flush() returns integer {
		integer rID := integer.incrementCounter("apama.ConnectivityFlushRequest");
		send control.Flush(rID, context.current()) to "com.softwareag.connectivity.chaincontrol." + getId();
		return rID;
	}
	
	/** @private */
	chunk chain;
}

/**
 * Utility event to provide string literals for direction.
 */
event Direction {
	/**
	 * The direction of messages flowing towards the transport (from the host).
	 */
	constant string TOWARDS_TRANSPORT := "TOWARDS_TRANSPORT";
	
	/**
	 * The direction of messages flowing towards the host (from the transport).
	 */
	constant string TOWARDS_HOST := "TOWARDS_HOST";
}

/**
 * Utilities for interacting with connectivity plug-ins.
 */
event ConnectivityPlugins
{
	/** @private */
	import "ConnectivityPlugin" as _plugin;

	/** Should be called by EPL applications after all EPL has been injected
	 * and initialized, to indicate that the application is ready to receive
	 * events from connectivity plug-ins.
	 *
	 * This will also enable reception of JMS events if correlator-integrated
	 * JMS is enabled (That is, it implicitly calls
	 * JMSPlugin.onApplicationInitialized)
	 *
	 * Invoking this action more than once is an error and will throw an
	 * exception.
	 *
	 */
	static action onApplicationInitialized()
	{
		_plugin.onApplicationInitialized();
	}
	/** 
	 * Create and start a chain instance from the given chain definition listed in dynamicChains in the configuration file.
	 *
	 * This action returns a Chain that has already been created and started. It is immediately able to receive events.
	 *
	 * @deprecated [This action has been deprecated. Please use createDynamicChain instead.]
	 *
	 * @param chainInstanceId The unique identifier to use for the new chain instance. This identifier is used for logging, and for looking up existing Chain objects by id.
	 * Caution: A small amount of memory is allocated for each unique chain instance identifier. This memory is not freed when the chain is destroyed. Therefore, if you are creating many chains, consider reusing old chain instance identifiers. If you create more than 1000 unique identifiers, a warning is written to the correlator log file to notify you of this. You cannot have two active chains with the same chain instance identifier, so only reuse identifiers which are no longer in use.
	 * @param channels The list of channels this chain should subscribe to
	 * @param chainDefnName The name of a chain definition listed under dynamicChains in the configuration file
	 * @param substitutions Dictionary providing values for <code>@{...}</code> dynamic substitution variables in the chain definition
	 * @return A Chain object which can be used to destroy this chain later
	 */
	static action createChain(string chainInstanceId, sequence<string> channels, string chainDefnName, dictionary<string, string> substitutions) returns Chain 
	{
		return Chain(_plugin.createChain(chainInstanceId, channels, chainDefnName, substitutions));
	}
	
	/** 
	 * Create and start a chain instance from the given chain definition listed in dynamicChains in the configuration file.
	 *
	 * This action returns a Chain that has already been created and started. It is immediately able to receive events.
	 *
	 * @param chainInstanceId The unique identifier to use for the new chain instance. This identifier is used for logging, and for looking up existing Chain objects by id.
	 * @param channels The list of channels this chain should subscribe to
	 * @param chainDefnName The name of a chain definition listed under dynamicChains in the configuration file
	 * @param substitutions Dictionary providing values for <code>@{...}</code> dynamic substitution variables in the chain definition
	 * @param defaultChannelTowardsHost Default channel to use for sending a message towards the host if no channel is specified on the message. 
	 * Use an empty string for no default channel. It is an error to specify non-empty defaultChannelTowardsHost value if defaultChannel is also
	 * specified for the host plug-in.
	 * @return A Chain object which can be used to destroy this chain later
	 */
	static action createDynamicChain(string chainInstanceId, sequence<string> channels, string chainDefnName, dictionary<string, string> substitutions, string defaultChannelTowardsHost) returns Chain 
	{
		return Chain(_plugin.createDynamicChain(chainInstanceId, channels, chainDefnName, substitutions, defaultChannelTowardsHost));
	}
	
	/**
	 * Look up a chain instance by its identifier. This can retrieve
	 * dynamically created chains, as well as statically created chains from
	 * 'startChains' in the correlator configuration.
	 *
	 * An exception is thrown if no chain exists with this identifier.
	 *
	 * @param chainInstanceId The unique identifier of the chain instance
	 * @return The chain instance
	 */
	static action getChainById(string chainInstanceId) returns Chain {
		return Chain(_plugin.getChainById(chainInstanceId));
	}
	
	/**
	 * Look up a chain instance by a channel it is subscribed to or sending to.
	 *
	 * There must be exactly one chain matching the requested combination of
	 * channel and direction, else an exception is thrown.
	 * 
	 * The direction of the channel specifies how the channel is used by the chain instance. 
	 * The TOWARDS_TRANSPORT direction means that the channel is one of the channels that 
	 * the chain instance is subscribed to to receive events from the host. The TOWARDS_HOST 
	 * direction means that the channel is used by the chain instance as the default channel 
	 * to deliver events from the transport to the host.
	 * 
	 * @param channel The channel to use for lookup. 
	 * @param direction Specifies the direction in which the channel is used by the chain instance. 
	 * Use the constants defined in the Direction event for string literals.
	 * @see com.softwareag.connectivity.Direction
	 */
	static action getChainByChannel(string channel, string direction) returns Chain {
		return Chain(_plugin.getChainByChannel(channel, direction));
	}
}

 00000043 C:\dev\apama_win_full_latest\Apama\monitors\ConnectivityPlugins.mon
MONF 00000593 /*
 * $Copyright (c) 2016-2018 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.$
 * Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG
 * $Revision: 294001 $ $Date: 2016-10-28 18:45:56 +0100 (Fri, 28 Oct 2016) $
 */

//*****************************************************************************
// Title:         Connectivity starter
// Description:   Starts connectivity plug-ins.  Remove this bundle for more fine-grained control over when connectivity starts.
// Dependencies:  None
// Author:        CREE
//
//*****************************************************************************

package com.apama.connectivity;

/** Notify that the application has been started.
 *
 * This event should be sent in to the correlator after all EPL files have been injected, and will result in
 * ConnectivityPlugins.onApplicationInitialized() being called, allowing the incoming messages to be received from
 * connectivity plug-ins and JMS.
 */
event ApplicationInitialized {
}

/** Monitor to start connectivity */
monitor ApplicationInitializedTransports {
	action onload() {
		on ApplicationInitialized() {
			com.softwareag.connectivity.ConnectivityPlugins.onApplicationInitialized();
		}
	}
}

 00000051 C:\dev\apama_win_full_latest\Apama\monitors\AutomaticOnApplicationInitialized.mon
MONF 0000c797 /*
 * $Copyright (c) 2012 Progress Software Corporation and/or its subsidiaries and affiliates. All rights reserved.$ 
 * $Copyright (c) 2013-2014, 2016-2018 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.$ 
 * Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG 
 *
 * Event definitions for the Correlator-integrated Apama JMS adapter. 
 *
 * $Revision: 328106 $
 *
 */
package com.apama.correlator.jms;


// *****************************************************************************
// 
// Private event definitions - for internal use only. 
//

/** @private*/ event __AddSender
{
	string connectionId;
	string senderId;
	string senderReliability;
	dictionary<string,string> extraAddParams;
}

/** @private*/ event __RemoveSender
{
	string senderId;
}

/** @private*/ event __AddReceiver
{
	string connectionId;
	string receiverId;
	string destination;
	string receiverReliability;
	string durableTopicSubscriptionName;
	string messageSelector;
	boolean noLocal;
	dictionary<string,string> extraAddParams;
}

/** @private*/ event __RemoveReceiver
{
	string receiverId;
}

/** @private*/ event __JMSReceiverFlowControlWindowUpdate
{
	string receiverId;
	integer __processInstanceToken;
	integer __flowControlMarker;
	integer __flowControlWindow;
}

/** @private*/ event __ReceiverAcknowledgeAndResume
{
	string receiverId;
}

/** @private*/ event __JMSSenderFlush
{
	integer requestId;
	string channelName;
}

// *****************************************************************************
// 
// Public event API for dynamically adding/removing JMS senders and receivers
//
// To be notified about the successful addition or removal of senders and 
// receivers, applications should listen for the separate Sender/ReceiverStatus 
// events, looking for the OK or REMOVED status. 
//

/** An enumeration containing constants for the currently supported sender 
	reliability values.
*/
event JMSSenderReliability
{
	/** Best effort non-reliable messaging; events may be lost or duplicated 
		if a component fails. */
	constant string BEST_EFFORT := "BEST_EFFORT";
	/** Reliable messaging without duplicate detection. 
	
		Events may be  duplicated or reordered if a component fails, but will 
		not be lost. */
	constant string AT_LEAST_ONCE := "AT_LEAST_ONCE";
	/** Reliable messaging with duplicate detection identifiers. 
	
		Events may be reordered if a component fails, but will not be lost, 
		and will not be duplicated if the unique message ids are mapped into 
		the message and the receiving JMS client uses an appropriate duplicate 
		detection window. */
	constant string EXACTLY_ONCE := "EXACTLY_ONCE";
}

/** An enumeration containing constants for the message delivery modes for sender.
*/
event JMSMessageDeliveryMode
{
	/** Use PERSISTENT message delivery mode for sending messages to the broker.
	
		Reliable senders always use PERSISTENT message delivery mode.
	*/
	constant string PERSISTENT := "PERSISTENT";
	
	/** Use NON_PERSISTENT message delivery mode for sending messages to the broker.
	
		This is the default for BEST_EFFORT senders.
	*/
	constant string NON_PERSISTENT := "NON_PERSISTENT";
}

/** An event object representing an existing JMS sender. 
 *
 * A JMS sender has an associated channel to which Apama events can be "sent", 
 * which will then be mapped to JMS messages using the requested message 
 * reliability setting and delivered to a destination on the JMS message bus. 
 */
event JMSSender
{
	// Public
	
	/** Returns the unique identifier of this sender. */
	action getSenderId() returns string { return __senderId; }
	
	/** Returns the Correlator channel to use for events that should 
	 * be delivered to JMS using this sender. 
	 *
	 * Note that if this senderId does not exist or has been removed then 
	 * events sent to this channel will be lost without a warning. 
	 */
	action getChannel() returns string { return __channel; }
	
	/** Requests removal of this JMS sender. The removal will be performed 
	 * asynchronously, and completes after all events already sent by this 
	 * context have been passed to JMS, and the associated JMS producer and 
	 * session have been closed. 
	 *
	 * EPL applications may listen for the REMOVED JMSSenderStatus event to 
	 * detect when the removal has completed. 
	 *
	 * If the connection is currently down there could be an unbounded delay 
	 * in completing the removal of the sender. The application should not 
	 * send any more events to the sender channel once this action has been 
	 * called. 
	 *
	 * It is an error to attempt to remove a JMS sender that does not exist, or 
	 * to attempt to remove a static JMS sender. Such errors will result in 
	 * the termination of the current EPL monitor instance. 
	 * 
	 * @see JMSSenderStatus#REMOVED
	 */
	action remove()
	{
		__plugin.processControlEvent(__RemoveSender(__senderId).toString());
	}

	/** Returns the number of events that have been send to this sender's 
	 * channel from the application, but are still queued waiting to be sent to 
	 * JMS.
	 *
	 * This allows an EPL application to throttle or reduce the rate at which 
	 * it sends events based on the size of the backlog building up in the 
	 * Correlator's queues, to ensure that the Correlator does not run out of 
	 * memory due to a temporary peak in throughput rate or loss of the JMS 
	 * connection. 
	 *
	 * Calling this action is a slightly expensive operation, so it is best to 
	 * get the number of outstanding events once, then loop sending a batch of 
	 * events. Therefore do not call getOutstandingEvents inside a loop that is 
	 * continually sending events to JMS. 
	 *
	 * You must not call this method after calling remove().
	 */
	action getOutstandingEvents() returns integer
	{
		return __plugin.getOutstandingMessages(__senderId);
	}
	
	/** Requests a notification event after flushing all messages 
	 * already sent to the sender's channel by the current context. 
	 *
	 * A JMSSenderFlushed event will be sent to this context when all the 
	 * messages already sent to the sender channel have been processed 
	 * and passed to the JMS broker (or dropped, in the case of 
	 * non-recoverable mapping errors). 
	 *
	 * This feature is only applicable to BEST_EFFORT senders, as for 
	 * AT_LEAST_ONCE/EXACTLY_ONCE senders reliability is already taken care of 
	 * by the integration with Correlator state persistence. It is an error 
	 * to call this action from a persistent monitor. 
	 * 
	 * Applications may have multiple flush requests in flight at any one time. 
	 * Performance will be improved by sending multiple messages (e.g. 1000) 
	 * between each flush request.
	 *
	 * @returns The unique request id for flush request, which will be included 
	 * in the resulting JMSSenderFlushed event.
	 *
	 * @see JMSSenderFlushed Notification event sent in response to 
	 */
	action requestFlush() returns integer
	{
		__plugin.checkNonPersistentMonitor("requestFlush");
		integer requestId := integer.incrementCounter("apama.JMSSenderFlushRequest");
		string privateChannel := "com.apama.jms.backchannel." + context.current().getId().toString();
		monitor.subscribe(privateChannel);
		send __JMSSenderFlush(requestId, privateChannel) to self.getChannel();
		return requestId;
	}
	
	// Private
	
	/** @private*/ string __senderId;
	/** @private*/ string __channel;
	/** @private*/ import "JMSPlugin" as __plugin;

}

/** An event object representing the configuration of a new JMS sender, for 
 * dynamically adding JMS senders at runtime. 
 *
 * Call JMSConnection.createSenderConfiguration() to create an instance, and 
 * then use the setter actions to specify each required configuration option. 
 * Each setter method returns this configuration instance to make it possible 
 * to chain calls and specify all required options in a single statement. 
 *
 * @see JMSConnection#createSenderConfiguration() Creates a new 
 *	JMSSenderConfiguration event object. 
 * @see JMSConnection#addSenderWithConfiguration() Uses a JMSSenderConfiguration 
 *	to add a new JMS sender. 
 */
event JMSSenderConfiguration
{
	/** The unique identifier of this sender. */
	action getSenderId() returns string
	{ return __senderId; }

	/** The identifier of the connection this sender belongs to. */
	action getConnectionId() returns string
	{ return __connectionId; }
	
	/** Specifies the reliability mode to use for messages from this sender. 
	 * @param value Must be one of the enumeration constants from the 
	 * JMSSenderReliability event, or "" to indicate that the connection's 
	 * defaultSenderReliability should be used. 
	 * @see JMSSenderReliability
	 */
	action setSenderReliability(string value) returns JMSSenderConfiguration
	{ __senderReliability := value; return self; }
	/** Specifies the reliability mode to use for messages from this sender. */
	action getSenderReliability() returns string
	{ return __senderReliability; }
	
	/** Specifies the message delivery mode to use for messages from this sender.
	 *
	 * This can be used only for non-reliable BEST_EFFORT senders.
	 * It is ignored for reliable senders which always use PERSISTENT message 
	 * delivery mode.
	 *
	 * @param value Must be one of the enumeration constants from the 
	 * JMSMessageDeliveryMode event, or "" to indicate that the default mode will be used
	 * @see JMSMessageDeliveryMode
	 */
	action setMessageDeliveryMode(string value) returns JMSSenderConfiguration
	{ __messageDeliveryMode := value; return self; }
	/** Specifies the message delivery mode to use for messages from this sender. */
	action getMessageDeliveryMode() returns string
	{ return __messageDeliveryMode; }
	
	// Private fields
	
	/** @private*/ string __connectionId;
	/** @private*/ string __senderId;
	/** @private*/ string __senderReliability;
	/** @private*/ string __messageDeliveryMode;
	
	/** Initializes this object with required parameters 
	 * @private*/ 
	action __init(string connectionId, string senderId) 
	{
		self.__connectionId := connectionId;
		self.__senderId := senderId;
	}
	
	/** @private*/ 
	action __getAddSender() returns __AddSender
	{
		return __AddSender(
			getConnectionId(), 
			getSenderId(), 
			getSenderReliability(),
			{"MessageDeliveryMode":getMessageDeliveryMode()}
			);
	}
}

/** A notification event sent to an EPL application in response to a sender 
 * flush request.
 * 
 * The application context will receive this event after all the messages 
 * already sent by the application at the time of the flush request have been 
 * processed and passed to the JMS broker (or dropped, in the case of 
 * non-recoverable mapping errors). 
 *
 * This event will be sent to the context that requested message flushing.
 *
 * @see JMSSender#requestFlush()
 */
event JMSSenderFlushed
{
	/** The unique request id returned by the flush request.*/
	integer requestId;
	/** The identifier of sender. */
	string senderId;
}

/** An enumeration containing constants for the currently supported receiver 
	reliability values.
*/
event JMSReceiverReliability
{
	/** Best effort non-reliable messaging; events may be lost or duplicated 
		if a component fails. */
	constant string BEST_EFFORT := "BEST_EFFORT";
	/** Reliable messaging without duplicate detection; events may be 
		duplicated or reordered if a component fails, but will not be lost. */
	constant string AT_LEAST_ONCE := "AT_LEAST_ONCE";
	/** Reliable messaging with duplicate detection; events may be 
		reordered if a component fails, but will not be lost, and will not be 
		duplicated provided the unique message ids and duplicate detection 
		window are configured correctly. */
	constant string EXACTLY_ONCE := "EXACTLY_ONCE";
	/** Reliable messaging with acknowledgements controlled by the application.
	*/
	constant string APP_CONTROLLED := "APP_CONTROLLED";
}

/** An event object representing an existing JMS receiver. 
 *
 * A receiver listeners for messages on a specific JMS queue or topic, maps 
 * them to Apama events and sends them to the Correlator's public contexts. 
 */
event JMSReceiver
{
	// Public
	
	/** Returns the unique identifier of this receiver. */
	action getReceiverId() returns string { return __receiverId; }
	
	
	/** Requests removal of this JMS receiver. 
	 *
	 * The removal will be performed asynchronously, and completes after all 
	 * events already received from this JMS destination have been enqueued to 
	 * the Correlator, any persisted uniqueMessageIds no longer required for 
	 * duplicate detection have been deleted, any durable topic subscription 
	 * has been removed from the JMS broker, and the associated JMS consumer 
	 * and session have been closed. 
	 *
	 * EPL applications may listen for the REMOVED JMSReceiverStatus event to 
	 * detect when the removal has completed. 
	 *
	 * If the connection is currently down there could be an unbounded delay 
	 * in completing the removal of the receiver. 
	 *
	 * It is an error to attempt to remove a JMS receiver that does not exist, 
	 * or to attempt to remove a static JMS receiver. Such errors will result 
	 * in the termination of the current EPL monitor instance. 
	 * 
	 * @see JMSReceiverStatus#REMOVED
	 */
	action remove()
	{
		__plugin.processControlEvent(__RemoveReceiver(__receiverId).toString());
	}
	
	
	/** Signals that the application is ready for messages received 
	 * since the last appControlledAcknowledgeAndResume() call to be 
	 * acknowledged to JMS, and that message receiving can then resume. 
	 *
	 * This is used only by receivers which are running in APP_CONTROLLED 
	 * reliability mode. APP_CONTROLLED receivers should listen for the 
	 * JMSAppControlledReceivingSuspended event enqueued at the end of each 
	 * batch of incoming messages and respond by calling 
	 * appControlledAcknowledgeAndResume() once the messages or the output 
	 * events/state changes resulting from processing them have been reliably 
	 * stored in another system (e.g. sent and flushed to a downstream JMS 
	 * destination, or committed to a database or distributed MemoryStore). 
	 *
	 * To avoid race conditions, it is important to call this method only from 
	 * the context that is handling both the JMS messages from this receiver 
	 * and the JMSAppControlledReceivingSuspended event. 
	 * 
	 * Never call this method except in response to a 
	 * JMSAppControlledReceivingSuspended event, and do not call it from 
	 * a persistent monitor - both will result in an exception.
	 *
	 * @see JMSAppControlledReceivingSuspended
	 */
	action appControlledAcknowledgeAndResume() {
		__plugin.processControlEvent(__ReceiverAcknowledgeAndResume(__receiverId).toString());
	}
	
	// Private
	
	/** @private*/ string __receiverId;
	/** @private*/ import "JMSPlugin" as __plugin;

}

/** A notification event sent to an EPL application every time an APP_CONTROLLED 
 * receiver suspends, at the end of each message batch. 
 *
 * The application should respond by taking whatever action is required to 
 * ensure that the messages received since the last suspend 
 * or the output events/state changes resulting from processing them 
 * have been reliably stored in another system (e.g. sent and flushed to 
 * a downstream JMS destination, or committed to a database or distributed MemoryStore). 
 *
 * Once these operations have completed the application should call 
 * JMSReceiver.appControlledAcknowledgeAndResume() to signal that the message 
 * batch can be acknowledged to JMS (i.e. no longer needs to be retained for 
 * possible resending in the event of crash) and that receiving can resume. 
 *
 * This event will be sent to the same context(s) that are handling the 
 * messages from this receiver. 
 * The event will be sent at the end of every message 'batch' 
 * (see "maxBatchSize" in the documentation for more details). 
 * @see JMSReceiver#appControlledAcknowledgeAndResume()
 */
event JMSAppControlledReceivingSuspended
{
	/** The unique identifier of the suspended receiver. */
	string receiverId;
}


/** An event object representing the configuration of a new JMS receiver, for 
 * dynamically adding JMS receivers at runtime. 
 *
 * Call JMSConnection.createReceiverConfiguration() to create an instance, and 
 * then use the setter actions to specify each required configuration option. 
 * Each setter method returns this configuration instance to make it possible 
 * to chain calls and specify all required options in a single statement. 
 *
 * @see JMSConnection#createReceiverConfiguration() Creates a new 
 *	JMSReceiverConfiguration event object. 
 * @see JMSConnection#addReceiverWithConfiguration() Uses a 
 *	JMSReceiverConfiguration to add a new JMS receiver. 
 */
event JMSReceiverConfiguration
{
	/** The unique identifier of this receiver. */
	action getReceiverId() returns string
	{ return __receiverId; }

	/** The identifier of the connection this receiver belongs to. */
	action getConnectionId() returns string
	{ return __connectionId; }
	
	/** The queue or topic this receiver will listen to. */
	action getDestination() returns string
	{ return __destination; }
	
	/** Specifies the reliability mode to use for receiving messages. 
	 * @param value Must be one of the enumeration constants from the 
	 *	JMSReceiverReliability event, or "" to indicate that the connection's 
	 *	defaultReceiverReliability should be used. 
	 * @see JMSReceiverReliability
	 */
	action setReceiverReliability(string value) returns JMSReceiverConfiguration
	{ __receiverReliability := value; return self; }
	/** Specifies the reliability mode to use for receiving messages. */
	action getReceiverReliability() returns string
	{ return __receiverReliability; }
	
	/** Specifies the unique identifier for the subscription if a durable topic 
	 * subscription is to be created.
	 * @param value A unique JMS subscription name if a durable topic 
	 *	subscription should be created, or "" if a non-durable topic 
	 *	subscription should be made. Only valid for topics, and only if the 
	 *	reliability is not BEST_EFFORT.
	 */
	action setDurableTopicSubscriptionName(string value) returns JMSReceiverConfiguration
	{ __durableTopicSubscriptionName := value; return self; }
	/** Specifies the unique identifier for the subscription if a durable topic 
	 * subscription is to be created. */
	action getDurableTopicSubscriptionName() returns string
	{ return __durableTopicSubscriptionName; }

	/** Specifies the JMS message selector query string to select a subset of 
	 * queue/topic messages to be processed by this receiver. 
	 * @param value A message selector string, or "" to receive all messages. 
	 * See the JMS documentation for the javax.jms.Message interface for more 
	 * details. 
	 */
	action setMessageSelector(string value) returns JMSReceiverConfiguration
	{ __messageSelector := value; return self; }
	/** Specifies the JMS message selector query string to select a subset of 
	 * queue/topic messages to be processed by this receiver. */
	action getMessageSelector() returns string
	{ return __messageSelector; }

	/** Specifies an application-defined identifier to override how receivers 
	 * are grouped together for duplicate-detection purposes when using 
	 * EXACTLY_ONCE reliability. 
	 * @param value An arbitrary (but preferably short) string defined by the 
	 *	EPL application. All EXACTLY_ONCE receivers with this string will be 
	 *	grouped together to form a single duplicate detection domain. 
	 *
	 *	This is an advanced feature - by default, receivers are grouped into 
	 *	a duplicate detection domain together with other receivers in the 
	 *	same connectionId listening to the same destination, which is the 
	 *	correct setting in the majority of cases. 
	 */
	action setDupDetectionDomainId(string value) returns JMSReceiverConfiguration
	{ __dupDetectionDomainId := value; return self; }
	/** Specifies an application-defined identifier to override how receivers 
	 * are grouped together for duplicate-detection purposes when using 
	 * EXACTLY_ONCE reliability. */
	action getDupDetectionDomainId() returns string
	{ return __dupDetectionDomainId; }

	/** Specifies that messages sent to this destination by our own connection 
	 * should be ignored by the receiver. 
	 * @param value May be set to true or false for topic destinations. If 
	 *	the destination is a queue, the behaviour of noLocal=true is not 
	 *	specified, and will not work with many providers. The default value of 
	 *	false is usually fine. 
	 */
	action setNoLocal(boolean value) returns JMSReceiverConfiguration
	{ __noLocal := value; return self; }
	/** Specifies that messages sent to this destination by our own connection 
	 * should be ignored by the receiver. */
	action getNoLocal() returns boolean
	{ return __noLocal; }
	
	// Private fields
	
	/** @private*/ string __connectionId;
	/** @private*/ string __receiverId;
	/** @private*/ string __destination;
	/** @private*/ string __receiverReliability;
	/** @private*/ string __durableTopicSubscriptionName;
	/** @private*/ string __messageSelector;
	/** @private*/ string __dupDetectionDomainId;
	/** @private*/ boolean __noLocal;
	
	
	/** Initializes this object with required parameters 
	 * @private*/ 
	action __init(string connectionId, string receiverId, string destination) 
	{
		self.__connectionId := connectionId;
		self.__receiverId := receiverId;
		self.__destination := destination;
	}
	/** Initializes this object with required parameters 
	 * @private*/ 
	action __getAddReceiver() returns __AddReceiver
	{
		__AddReceiver result := new __AddReceiver;
		result.connectionId := getConnectionId();
		result.receiverId := getReceiverId();
		result.destination := getDestination();
		result.receiverReliability := getReceiverReliability();
		result.durableTopicSubscriptionName := getDurableTopicSubscriptionName();
		result.messageSelector := getMessageSelector();
		result.noLocal := getNoLocal();
		if getDupDetectionDomainId() != "" { result.extraAddParams["dupDetectionDomainId"] := getDupDetectionDomainId(); }
		
		return result;
	}
}

/** An event object representing a JMS connection, with actions for 
 * manipulating a connection's existing senders and receivers, and also for 
 * dynamically adding senders and receivers at runtime. 
 *
 * Senders and receivers may be added dynamically either using the 
 * comprehensive JMSConnection.addReceiver/SenderWithConfiguration() actions 
 * which provide access to all configuration parameters, or one of the 
 * other addReceiver/Sender*() actions that simplify creation of 
 * senders/receivers using the more common configuration parameter sets. 
 *
 * @see JMS#getConnection() Use this method to get a JMSConnection
 */
event JMSConnection
{
	// Public
	
	/** The unique identifier of this connection. */
	action getConnectionId() returns string 
	{
		return __connectionId;
	}

	/** Get a JMSReceiver event object representing a receiver that already 
	 * exists, which might have been added dynamically, or defined statically 
	 * in the XML configuration file. 
	 *
	 * It is the caller's responsibility to specify a valid receiverId - the  
	 * specified identifier is not be validated as part of this action call. 
	 * If the identifier does not represent an existing receiver then 
	 * operations on the returned JMSReceiver (such as remove()) will cause an 
	 * error. 
	 */
	static action getReceiver(string receiverId) returns JMSReceiver { return JMSReceiver(receiverId); }
	
	/** Get a JMSSender event object representing a sender that already 
	 * exists, which might have been added dynamically, or defined statically 
	 * in the XML configuration file. 
	 *
	 * It is the caller's responsibility to specify a valid senderId - the  
	 * specified identifier is not be validated as part of this action call. 
	 * If the identifier does not represent an existing sender then 
	 * operations on the returned JMSSender (such as remove()) will cause an 
	 * error. 
	 */
	static action getSender(string senderId) returns JMSSender { return JMSSender(senderId, "jms:"+senderId); }

	/** Get a JMSSender event object representing the default sender for this 
	 * connection (which exists automatically if no other static senders 
	 * were explicitly configured). 
	 */
	action getDefaultSender() returns JMSSender { return getSender(__connectionId+"-default-sender"); }

	
	/** Requests the addition of a new dynamic JMS sender, with the specified 
	 * reliability setting. 
	 *
	 * EPL applications may listen for the JMSSenderStatus event to be notified 
	 * when the new sender has been added, and when it has reached the 
	 * "OK" state. Events can be sent to the sender's channel as soon as 
	 * this action returns. 
	 *
	 * A unique senderId will be generated automatically. 
	 *
	 * The monitor instance will usually be terminated with an ERROR if invalid 
	 * arguments are provided. 
	 *
	 * @param senderReliability An enumeration value from JMSSenderReliability 
	 * indicating the reliability setting to use for sending events. 
	 * Alternatively, specify an empty string "" to use the connection's 
	 * defaultSenderReliability. 
	 *
	 * @return A JMSSender instance which can be used to get the senderId for 
	 * status monitoring, the channel to send events to, and an action for 
	 * removing the sender when it is no longer required. 
	 * @see JMSSenderReliability
	 */
	action addSender(string senderReliability) returns JMSSender
	{
		return addSenderWithConfiguration(createSenderConfiguration(__makeUniqueId("sender", senderReliability))
			.setSenderReliability(senderReliability));
	}
	
	
	/** Requests the addition of a new dynamic JMS sender, with the specified 
	 * sender configuration. 
	 *
	 * EPL applications may listen for the JMSSenderStatus event to be notified 
	 * when the new sender has been added, and when it has reached the 
	 * "OK" state. Note that no events will actually be sent into the 
	 * Correlator until JMS.onApplicationInitialized() has been called. 
 	 *
	 * The monitor instance will usually be terminated with an ERROR if invalid 
	 * arguments are provided. 
	 *
	 * @param config An event representing the configuration of the new sender, 
	 * constructed using JMSConnection.createSenderConfiguration and the 
	 * setter methods on JMSSenderConfiguration.
	 *
	 * @return A JMSSender instance which can be used to get the senderId for 
	 * status monitoring, the channel to send events to, and an action for 
	 * removing the sender when it is no longer required. 
	 *
	 * @see JMSConnection#createSenderConfiguration()
	 */
	action addSenderWithConfiguration(JMSSenderConfiguration config) returns JMSSender
	{
		__plugin.processControlEvent(config.__getAddSender().toString());
		return getSender(config.getSenderId());
	}
	
	/** Create a JMSSenderConfiguration for this connection that can be 
	 * used to add a new sender with the specified settings. 
	 *
	 * @param senderId An application-defined unique identifier for this 
	 * sender, used to track status and removal. The senderId must not be an 
	 * empty string or contain the colon ":" character - if it does, the 
	 * monitor will terminate with an error when trying to create the sender.
	 *
	 * Applications are encouraged to use <tt>integer.incrementCounter("apama.JMSSessionId").toString()</tt> 
	 * or a similar generator of unique numbers for all or part of the senderId. 
	 *
	 * @see JMSConnection#addSenderWithConfiguration()
	 */
	action createSenderConfiguration(string senderId) returns JMSSenderConfiguration
	{
		JMSSenderConfiguration result := new JMSSenderConfiguration;
		result.__init(__connectionId, senderId);
		return result;
	}

	/** Requests the addition of a new dynamic JMS receiver, with the specified 
	 * queue/topic name and reliability setting. 
	 *
	 * EPL applications may listen for the JMSReceiverStatus event to be 
	 * notified when the new receiver has been added, and when it has reached 
	 * the "OK" state. 
	 *
	 * A unique receiverId will be generated automatically. 
	 *
	 * The monitor instance will usually be terminated with an ERROR if invalid 
	 * arguments are provided. 
	 *
	 * @param destination A JMS queue name, JMS topic name, or JNDI name, 
	 *	prefixed by <tt>"queue:"</tt>, <tt>"topic:"</tt> or <tt>"jndi:"</tt>.
	 
	 * @param receiverReliability An enumeration value from 
	 *	JMSReceiverReliability indicating the reliability setting to use. 
	 *	Alternatively, specify an empty string "" to use the connection's 
	 *	defaultReceiverReliability. 
	 *
	 * @return A JMSReceiver instance which can be used to get the receiverId 
	 *	for status monitoring, and an action for removing the receiver when it 
	 *	is no longer required. 
	 * @see JMSReceiverReliability
	 */
	action addReceiver(string destination, string receiverReliability) returns JMSReceiver
	{
		return addReceiverWithConfiguration(
			createReceiverConfiguration(__makeUniqueId("receiver", destination), destination)
			.setReceiverReliability(receiverReliability));
	}

	/** Requests the addition of a new dynamic JMS durable topic subscription. 
	 *
	 * EPL applications may listen for the JMSReceiverStatus event to be 
	 * notified when the new receiver has been added, and when it has reached 
	 * the "OK" state. 
	 *
	 * This durable topic subscription will remain on the JMS broker until this 
	 * dynamic receiver is removed using JMSReceiver.remove(). 
	 *
	 * A unique receiverId will be generated automatically. 
	 *
	 * The monitor instance will usually be terminated with an ERROR if invalid 
	 * arguments are provided. 
	 *
	 * @param destination A JMS topic name, or JNDI name, 
	 *	prefixed by <tt>"topic:"</tt> or <tt>"jndi:"</tt>.
	 *
	 * @param receiverReliability An enumeration value from 
	 *	JMSReceiverReliability indicating the reliability setting to use.
	 
	 *	For a durable topic subscription, this must not be BEST_EFFORT.  
	 *	Specify an empty string "" to use the connection's 
	 *	defaultReceiverReliability. 
	 *
	 * @param durableTopicSubscriptionName The unique identifier used by the 
	 *	JMS broker for for this durable topic subscription. 
	 *
	 *	Must not be "", and must not match any other subscription name with the 
	 *	same connection clientID. 
	 *
	 * @param messageSelector An optional JMS message selector query string to 
	 *	select a subset of topic messages to be processed by this receiver, or 
	 *	"" to receive all messages. 
	 *
	 *	See the JMS documentation for the javax.jms.Message interface for more 
	 *	details. 

	 * @return A JMSReceiver instance which can be used to get the receiverId 
	 *	for status monitoring, and an action for removing the receiver when it 
	 *	is no longer required. 
	 * @see JMSReceiverReliability
	 * @see JMSReceiver#remove()
	 */
	action addReceiverWithDurableTopicSubscription(string destination, string receiverReliability, 
		string durableTopicSubscriptionName, string messageSelector) returns JMSReceiver
	{
		return addReceiverWithConfiguration(
			createReceiverConfiguration(__makeUniqueId("durable-subscriber", durableTopicSubscriptionName), destination)
			.setReceiverReliability(receiverReliability)
			.setMessageSelector(messageSelector)
			.setDurableTopicSubscriptionName(durableTopicSubscriptionName)
			);
	}

	/** Requests the addition of a new dynamic JMS receiver, with the specified 
	 * receiver configuration. 
	 *
	 * EPL applications may listen for the JMSReceiverStatus event to be 
	 * notified when the new receiver has been added, and when it has reached 
	 * the "OK" state. 
	 *
	 * The monitor instance will usually be terminated with an ERROR if invalid 
	 * arguments are provided. 
	 *
	 * @param config An event representing the configuration of the new 
	 * receiver, constructed using JMSConnection.createReceiverConfiguration 
	 * and the setter methods on JMSReceiverConfiguration.
	 *
	 * @return A JMSReceiver instance which can be used to get the receiverId 
	 * for status monitoring, and an action for removing the receiver when it 
	 * is no longer required. 
	 *
	 * @see JMSConnection#createReceiverConfiguration()
	 */
	action addReceiverWithConfiguration(JMSReceiverConfiguration config) returns JMSReceiver
	{
		__plugin.processControlEvent(config.__getAddReceiver().toString());
		return getReceiver(config.getReceiverId());
	}
	
	/** Create a JMSReceiverConfiguration for this connection that can be 
	 * used to add a new receiver with the specified settings. 
	 *
	 * @param receiverId An application-defined unique identifier for this 
	 * receiver, used to track status and removal. The receiverId must not be an 
	 * empty string or contain the colon ":" character - if it does, the 
	 * monitor will terminate with an error when trying to create the receiver.
	 *
	 * Applications are encouraged to use <tt>integer.incrementCounter("apama.JMSSessionId").toString()</tt> 
	 * or a similar generator of unique numbers for all or part of the receiverId. 
	 *
	 * @param destination A JMS queue name, JMS topic name, or JNDI name, 
	 * prefixed by <tt>"queue:"</tt>, <tt>"topic:"</tt> or <tt>"jndi:"</tt>.
	 *
	 * @see JMSConnection#addReceiverWithConfiguration()
	 */
	action createReceiverConfiguration(string receiverId, string destination) returns JMSReceiverConfiguration
	{
		JMSReceiverConfiguration result := new JMSReceiverConfiguration;
		result.__init(__connectionId, receiverId, destination);
		return result;
	}
	
	// Private
	
	/** @private*/ string __connectionId;
	/** @private*/ import "JMSPlugin" as __plugin;
	
	/** @private*/ 
	action __makeUniqueId(string requiredSuffix, string optionalSuffix) returns string {
		string result := __connectionId+"-"+requiredSuffix;
		if optionalSuffix != "" {
			result := result+"-"+optionalSuffix;
		}
		result := result.replaceAll(":","-"); // ensure it's a valid identifier
		return result + "-" + integer.incrementCounter("apama.JMSSessionId").toString();
	}
	
}

/** The top-level event object representing the Correlator-integrated JMS 
 * runtime.
 */
event JMS
{
	// Public
	
	/** Should be called by EPL applications after all EPL has been injected 
	 * and initialized, to indicate that the application is ready to receive 
	 * events from the JMS runtime, such as received JMS messages and 
	 * status notification events. 
	 *
	 * Invoking this action more than once will have no effect. 
	 *
	 */
	static action onApplicationInitialized() 
	{
		__plugin.onApplicationInitialized();
	}
	
	/** Get a JMSConnection event object representing a connection defined  
	 * in the XML configuration file. 
	 */
	static action getConnection(string connectionId) returns JMSConnection
	{
		return JMSConnection(connectionId);
	}
	
	/** Get a JMSReceiver event object representing a receiver that already 
	 * exists, which might have been added dynamically, or defined statically 
	 * in the XML configuration file. 
	 *
	 * It is the caller's responsibility to specify a valid receiverId - the  
	 * specified identifier is not be validated as part of this action call. 
	 * If the identifier does not represent an existing receiver then 
	 * operations on the returned JMSReceiver (such as remove()) will cause an 
	 * error. 
	 */
	static action getReceiver(string receiverId) returns JMSReceiver { return JMSConnection.getReceiver(receiverId); }
	
	/** Get a JMSSender event object representing a sender that already 
	 * exists, which might have been added dynamically, or defined statically 
	 * in the XML configuration file. 
	 *
	 * It is the caller's responsibility to specify a valid senderId - the  
	 * specified identifier is not be validated as part of this action call. 
	 * If the identifier does not represent an existing sender then 
	 * operations on the returned JMSSender (such as remove()) will cause an 
	 * error. 
	 */
	static action getSender(string senderId) returns JMSSender { return JMSConnection.getSender(senderId); }
	
	// Private
	
	/** @private*/ import "JMSPlugin" as __plugin;
}


//*****************************************************************************
//
// Status events
//

/** 
 * A notification event sent to an EPL application when a configured JMS 
 * connection encounters an error or changes state. 
 *
 * This event includes string constants for each supported status. 
 *
 * Note that all notification events will be held back until 
 * JMS.onApplicationInitialized() has been called. 
 */
event JMSConnectionStatus
{
	/** The unique identifier of the JMS connection. 
	*/
	string connectionId;

	/** An enumeration value specifying the status of the connection. The 
	 * values in the enumeration are provided as constants in this event. 
	 *
	 * If the status is OK then the connection is up. 
	 */
	string status;
	
	/** A user-readable string specifying the cause of the error. This should 
		always be a non-empty string when the status is "ERROR". */
	string errorMessage;
	
	/** Additional status information items. None are currently supported. */
	dictionary<string,string> extraStatusInfo;
	
	// enumeration constants for status field value:
	
	/** The status value indicating that the Correlator-JMS runtime is fully 
		connected to the JMS broker with a valid JMS Connection object. */
	constant string OK := "OK";
	
	/** The status value indicating that the Correlator-JMS runtime is trying
		to establish an initial connection.  */
	constant string CONNECTING := "CONNECTING";

	/** The status value indicating that the connection is not available due to 
		some non-fatal error condition; the Correlator-JMS runtime will keep 
		retrying in the background. */
	constant string ERROR := "ERROR";
}

/** 
 * A notification event sent to an EPL application when a configured JMS 
 * sender has been created successfully, encounters an error, or is removed. 
 *
 * This event includes string constants for each supported status, and 
 * fields specifying information about the configuration of this sender
 * (as specified when it was created). 
 *
 * Note that all notification events will be held back until 
 * JMS.onApplicationInitialized() has been called. 
 *
 * JMSSenderStatus events are sent for both static senders in the 
 * configuration file (or the implicitly defined default sender), and 
 * dynamic senders created with JMSConnection.addSender.
 */
event JMSSenderStatus
{
	/** The unique identifier of the JMS connection. 
	*/
	string connectionId;

	/** The unique identifier of this sender. 
	*/
	string senderId;

	/** An enumeration value specifying the status of the sender. The values
	 * in the enumeration are provided as constants in this event. 
	 *
	 * If the status is OK then the sender is functioning correctly; if it 
	 * is REMOVED then removal of the sender has completed.  
	 */
	string status;
	
	/** A user-readable string specifying the cause of the error. This is 
	 * guaranteed not empty if status="ERROR" or "FATAL_ERROR". */
	string errorMessage;
	
	/** Additional status information items. None are currently supported. */
	dictionary<string,string> extraStatusInfo;
	
	// enumeration constants for status field value:
	
	/** The status value indicating that the sender is fully connected to the 
		JMS broker with a valid JMS Producer object, and is available to send 
		messages. */
	constant string OK := "OK";
	
	/** The status value indicating that the sender is waiting for the 
		JMS connection or sender session to be established. */
	constant string CONNECTING := "CONNECTING";
	/** The status value indicating that the sender is not available due to 
		some non-fatal error condition; the Correlator-JMS runtime will keep 
		retrying in the background. */
	constant string ERROR := "ERROR";
	
	/** The status value indicating that the sender is not available due to 
		a fatal error condition. 
		
		Senders in this state are no longer useful and should be removed by the 
		EPL application (if dynamic) or the system administrator (if statically 
		defined in the XML config file). Note that the removal of such failed 
		senders does not happen automatically. */
	constant string FATAL_ERROR := "FATAL_ERROR";
	/** The status value indicating that the removal of a dynamic sender has 
		been completed, which will be sent some time after a sender removal 
		request, once all the associated state on the broker and the 
		Correlator's database has been removed. 
		
		In rare cases it's possible that a status event for a sender may be 
		sent after the REMOVED status; any such event should be ignored.  */
	constant string REMOVED := "REMOVED";
	
	// fields specifying the sender's configuration:

	/** Sender quality of service, specifying the reliability mode of the 
		messages from this sender. 
		
		One of the enumeration constants from the JMSSenderReliability event. */
	string senderReliability;

	/** Additional sender configuration parameters specified when it was added. 
	*/
	dictionary<string,string> extraAddParams;

}

/** 
 * A notification event sent to an EPL application when a configured JMS 
 * receiver has been created successfully, encounters an error, or is removed. 
 *
 * This event includes string constants for each supported status, and 
 * fields specifying information about the configuration of this receiver
 * (as specified when it was created). 
 *
 * Note that the ordering of JMSReceiverStatus events relative to received 
 * messages is not defined. Also note that notification events will be held 
 * back until JMS.onApplicationInitialized() has been called. 
 *
 * JMSReceiverStatus events are sent for both static receivers in the 
 * configuration file, and dynamic receivers created with 
 * JMSConnection.addReceiver.
 */
event JMSReceiverStatus
{
	/** The unique identifier of the JMS connection.  */
	string connectionId;
	
	/** The unique identifier of this receiver. */
	string receiverId;

	/** An enumeration value specifying the status of the receiver. The values
	 * in the enumeration are provided as constants in this event. 
	 *
	 * If the status is OK then the receiver is functioning correctly; if it 
	 * is REMOVED then removal of the receiver has completed.  
	 */
	string status;
	
	/** A user-readable string specifying the cause of the error. This is 
	 * guaranteed not empty if status="ERROR" or "FATAL_ERROR". */
	string errorMessage;

	// enumeration constants for status field value:
	
	/** The status value indicating that the receiver is fully connected to the 
		JMS broker with a valid JMS Consumer object, and is available to receive 
		messages. */
	constant string OK := "OK";
	
	/** The status value indicating that the receiver is waiting for the 
		JMS connection or receiver session to be established. */
	constant string CONNECTING := "CONNECTING";
	/** The status value indicating that the receiver is not available due to 
		some non-fatal error condition; the Correlator-JMS runtime will keep 
		retrying in the background. */
	constant string ERROR := "ERROR";

	/** The status value indicating the  receiver could not be found because of 
		a problem accessing the specified destination (i.e. a JMS or JNDI 
		error). */
	constant string DESTINATION_NOT_FOUND := "DESTINATION_NOT_FOUND"; 	

	/** The status value indicating that the receiver is not available due to 
		a fatal error condition. 
		
		Receivers in this state are no longer useful and should be removed by 
		the EPL application (if dynamic) or the system administrator (if 
		statically defined in the XML config file). The removal of such failed 
		receivers does not happen automatically. 
	*/
	constant string FATAL_ERROR := "FATAL_ERROR";

	/** The status value indicating that the removal of a dynamic receiver has 
		been completed, which will be sent some time after a receiver removal 
		request, once all the associated state on the broker and the 
		Correlator's database has been removed. 
		
		In rare cases it's possible that a status event for a receiver may be 
		sent after the REMOVED status; any such event should be ignored.  */
	constant string REMOVED := "REMOVED";
	
	/** Additional status information items. None are currently supported. */
	dictionary<string,string> extraStatusInfo;

	// fields specifying the receiver's configuration:
	
	/** A JMS queue name, JMS topic name, or JNDI name, prefixed by 
		<tt>"queue:"</tt>, <tt>"topic:"</tt> or <tt>"jndi:"</tt>. */
	string destination;
	/** Receiver quality of service, specifying the reliability mode used 
		for receiving messages. 
		
		One of the enumeration constants from the JMSReceiverReliability event*/
	string receiverReliability;
	/** A unique JMS subscription name if a durable topic subscription should 
		be created, or "" if a non-durable topic subscription should be made. */
	string durableTopicSubscriptionName;
	/** JMS message selector string, to specify a subset of messages from the 
		destination to be processed by this receiver. 
	*/
	string messageSelector;
	/** Specifies that messages sent to this destination by our own connection 
		should be ignored by the receiver. */
	boolean noLocal;
	/** Additional receiver configuration parameters. None currently supported. */
	dictionary<string,string> extraAddParams;
}

//*****************************************************************************
//
// Advanced control events
//


/** A control event periodically sent to an EPL application for each receiver 
 * with receiverFlowControl enabled, which the application uses to update 
 * the flow control window.
 *
 * This event is used as a baseline from which the EPL application specifies 
 * the size of the window of new events it is currently ready to receive, 
 * specified relative to the last event received before this marker. 
 *
 * The event is sent:
 * i) when a receiver with receiverFlowControl=true is first added 
 * (once onApplicationInitialized has been called), 
 * ii) during recovery (in a persistent correlator), and 
 * iii) also periodically as JMS messages are received and 
 * enqueued to the correlator (typically these events are sent as often as 
 * the configured maxBatchSize, e.g. at least once every 1000 events). 
 *
 * To correctly implement the receiver flow control protocol, applications must 
 * respond to this event by calling updateFlowControlWindow (see below) 
 * to indicate the maximum number of additional events that the JMS runtime 
 * should take from this receiver, using the point in the event stream at 
 * which this marker was received as the baseline. 
 *
 * Applications that wish to  use flow control to throttle message receiving 
 * based on the number of outstanding asynchronous operations from 
 * already-received messages (to put a finite bound on memory usage) should 
 * also cache the most recent JMSReceiverFlowControlMarker for each 
 * active JMSReceiver so that the flow control window can be updated 
 * (e.g. extended) as pending operations complete, since there is no guarantee 
 * another JMSReceiverFlowControlMarker event will be sent until the window 
 * is extended enough for more events to be received. 
 *
 * Note that the fields of this event (apart from receiverId) are intended as 
 * 'opaque' data for internal use only and should be ignored by customer code.
 *
 * @see JMSReceiverFlowControlMarker#updateFlowControlWindow() Set the flow 
 * control window for this receiver, relative to this marker. 
 */ 
event JMSReceiverFlowControlMarker
{
	/** The unique identifier of this receiver. */
	string receiverId;
	
	/** For internal use only, treat as opaque data. */ 
	integer __processInstanceToken;
	
	/** For internal use only, treat as opaque data. */ 
	integer __flowControlMarker;
	
	/**
	* Sets the current flow control window size for a given receiver, which 
	* indicates the number of extra Apama events that should be taken from JMS 
	* and passed to the application before blocking, relative to the last data 
	* event received before this marker. 
	*
	* @param windowSizeEvents The maximum number of new events that should be 
	* received from this JMS receiver and enqueued to the correlator, relative 
	* to the position in the event flow indicated by this marker. 
	* The window size may be a constant number (e.g. 10,000 events) for 
	* applications that immediately process received events to completion,
	* or it may have a number of 'pending' events subtracted from it to create 
	* a bound on on the number of events that may be received from the JMS 
	* broker but are not yet been fully processed by the application (e.g. if 
	* an asynchronous database operation must complete before the memory, data 
	* structures or event listeners associated with the event may be deleted).
	*
	* It is valid to supply a zero or negative number for this value, in which 
	* case the JMS runtime will attempt to pause receiving, and take no more 
	* messages from the JMS queue/topic until this action is called again 
	* with a positive window (though it is not possible to guarantee that the 
	* flow of events will stop immediately, since some events could already be 
	* queued up). To allow an unbounded number of events to be received, 
	* specify integer.MAX for windowSizeEvents.
	* 
	* It is important that the overall long-term maximum window size 
	* (i.e. the chosen constant upper bound, ignoring any currently pending 
	* operations) is greater than than the receiver's maxBatchSize 
	* (typically 1000). 
	*/
	action updateFlowControlWindow(integer windowSizeEvents)
	{
		// use 'UnlessDisabled' as this should be a no-op when JMS is disabled, to support replay log
		__plugin.processControlEventUnlessDisabled(__JMSReceiverFlowControlWindowUpdate(
			receiverId, __processInstanceToken, __flowControlMarker, windowSizeEvents).toString()
		);
	}
	
	/** @private*/ import "JMSPlugin" as __plugin;
}
 00000043 C:\dev\apama_win_full_latest\Apama\monitors\CorrelatorJMSEvents.mon
TIME 0000000e 1568127087.9,1
MONF 00002fd8 //*****************************************************************************
// Title:       StatusSupport
// Description: Provides event definitions for generic status reporting from  
//              service monitors.
//
// Revision:    $Revision: 357639 $
//
// $Copyright(c) 2006-2007, 2008-2009, 2011-2012 Progress Software Corporation (PSC). All rights reserved.$
// $Copyright (c) 2013-2015, 2019 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.$
// Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG
//
//*****************************************************************************

package com.apama.statusreport;

/*
	The events defined in this file act as an API between applications
	and service monitors.  They provide functionality to 
	Subscribe to status messages.
	
	The aim of this API is to provide an abstraction over any adapter
	specific details - for example, some adapters may require an explicit 
	call to subscribe to such data, some may be sent it anyway.
	
	Any adapter specific information that the application needs to supply
	or be supplied can be passed in the extraParams dictionary - these 
	are free-form (though there are conventions on the keys, see below).
	
	The service monitor also needs to handle any session initiation that
	may be required.
	
	A Status event does not denote a change of state, merely what the current
	state is - in particular, one will be sent out after every 
	SubscribeStatus request.

	All operations and responses are keyed on serviceId (if non-blank), 
	object,	connection and subServiceID. Every event starts with these 4 
	fields.
	
*/


/**
 *	Sent to the SubscribeStatus chanenl to subscribe to status.
 *	
 */
event SubscribeStatus {
	constant string CHANNEL := "SubscribeStatus";
	/**
	 *	service ID to subscribe to - blank will target all services.
	 */
	string serviceID;
	
	/**
	 *	object to request status of - this may include:
	 *	"Connection" - whether connected or not
	 *	"Market" - a market may be "Open", "Closed", or other states
	 */
	string object;
	
	/**
	 *	subService ID to subscribe to.
	 *	Some services may expose several services.  The interpretation of
	 *	this string is adapter-specific.
	 */
	string subServiceID;
	
	/**
	 *	connection to subscribe to.
	 *	Some services may expose several services.  The interpretation of
	 *	this string is adapter-specific.
	 */
	string connection;
}

/**
 *	Sent to the service monitor to unsubscribe from status.
 *	
 */
event UnsubscribeStatus {	 
	constant string CHANNEL := "SubscribeStatus";
	/**
	 *	service ID to subscribe to - blank will target all services
	 */
	string serviceID;
	
	/**
	 *	object to request status of - this may include:
	 *	"Connection" - whether connected or not
	 *	"Market" - a market may be "Open", "Closed", or other states
	 */
	string object;
	
	/**
	 *	subService ID to subscribe to.
	 *	Some services may expose several services.  The interpretation of
	 *	this string is adapter-specific.
	 */
	string subServiceID;
	
	/**
	 *	connection to subscribe to.
	 *	Some services may expose several services.  The interpretation of
	 *	this string is adapter-specific.
	 */
	string connection;
}


/**
 *	Sent from the service monitor to the StatusReport channel to notify the application of status for a 
 *	subscribed item.
 *	
 */
event Status {	
	constant string CHANNEL := "StatusReport";
	/**
	 *	service ID to subscribe to - blank will target all services
	 */
	string serviceID;
	
	/**
	 *	object to request status of - this may include:
	 *	"Connection" - whether connected or not
	 *	"MarketState" - a market may be "Open", "Closed", or other states
	 */
	string object;
	
	/**
	 *	subService ID to subscribe to.
	 *	Some services may expose several services.  The interpretation of
	 *	this string is adapter-specific.
	 */
	string subServiceID;
	
	/**
	 *	connection to subscribe to.
	 *	Some services may expose several services.  The interpretation of
	 *	this string is adapter-specific.
	 */
	string connection;

	/**
	 *	status description.
	 *	A free-form text string giving a description of the status.
	 */
	string description;
	
	/**
	 *	A sequence of summary strings specifying information about the 
	 *	status of the specified object.  This will be a well recognized
	 *	sequence of words - for example, a financial market's
	 *	"MarketState" may be "Open", "Closed", "PreOpen", etc.  A Connection 
	 *	may be "Connected", "Disconnected", "Disconnected LoginFailed", 
	 *	"Disconnected TimedOut", etc. 
	 */
	sequence<string> summaries;

	/**
	 *	available.
	 *	True if the object is "available" - the exact meaning is adapter 
	 * 	specific; for example, connected, open for general orders, etc.
	 */
	 boolean available;
	 
	 /** 
	 *	extra parameters that do not map into any of the above.  Convention
	 *	is that keys are in TitleCase.  e.g. "Username", "CloseTime", etc.
	 */
	wildcard dictionary <string, string> extraParams;
}


event StatusError {
	constant string CHANNEL := "StatusReport";
	/**
	 *	service ID to subscribe to - blank will target all services
	 */
	string serviceID;
	
	/**
	 *	object to request status of - this may include:
	 *	"Connection" - whether connected or not
	 *	"MarketState" - a market may be "Open", "Closed", or other states
	 */
	string object;
	
	/**
	 *	subService ID to subscribe to.
	 *	Some services may expose several services.  The interpretation of
	 *	this string is adapter-specific.
	 */
	string subServiceID;
	
	/**
	 *	connection to subscribe to.
	 *	Some services may expose several services.  The interpretation of
	 *	this string is adapter-specific.
	 */
	string connection;

	/**
	 *	status description.
	 *	A free-form text string giving a description of the status.
	 */
	string description;
	
	/**
	 *	Whether the subscription has been terminated.  Any subscribers will 
	 *	need to send a new SubscribeStatus request after this.
	 */
	boolean failed;
}
	
//*****************************************************************************
// Title:         ParallelStatusSupport
// Description:   ParallelStatusSupport description
// Dependencies:  None
// Author:        arrustem
//
//*****************************************************************************

/*
	Event definitions for block subject event wrappers;
	These are provided for backwards compatibility.  Monitors listening to status should instead subscribe to the "StatusReport" channel.
*/
event SubscribeStatusToContext {
	context instanceContext;
	SubscribeStatus subscribe;
}

event UnsubscribeStatusToContext {
	context instanceContext;
	UnsubscribeStatus unsubscribe;
}

monitor ParallelStatusSupport {
	/*	dictionary < [serviceId] , sequence of contexts > eventRouter;
	 - eventRouter will keep track of all contexts that are listening to a particular symbol
	 - The same d.s. will be used for both, Status and StatusError
	   since they are added/removed precisely at the same time. 
	*/
	dictionary < string , sequence<context> > eventRouter;
	
	/*	dictionary < [serviceId], dictionary < [contextId], [key ctr] > > statusToContextCtr;
	 - Keeps count of number of listeners for each symbol on each context
	*/
	dictionary < string, dictionary < integer, integer > > statusToContextCtr;

	/*	dictionary < [serviceId], listener > statusListeners;
	 - keeps track of the local listeners for Status
		dictionary < [serviceId], listener > errorListeners;
	 - keeps track of the local listeners for StatusError
	*/
	dictionary < string, listener > statusListeners;
	dictionary < string, listener > errorListeners;
	
	action onload() {
		monitor.subscribe("StatusReport");
		// set up listeners for the wrapped events coming from subjects
		SubscribeStatusToContext subscribe;
		on all SubscribeStatusToContext():subscribe subscribeEventHandler(subscribe);
		
		UnsubscribeStatusToContext unsubscribe;
		on all UnsubscribeStatusToContext():unsubscribe unsubscribeEventHandler(unsubscribe);
	}
	
	action ondie() {
                // print out an error if statusToContextCtr is not empty
                if (statusToContextCtr.size() != 0) {
                        log "ParallelStatusSupport is terminating but there may still be contexts subscribed to Status events" at ERROR;
                }
                else {
                        log "ParallelStatusSupport is terminating" at INFO;
                }
	}
	
	action onunload() {
		// not doing anything here since it is assumed that only one instance of this monitor is executing 
	}
	
	action subscribeEventHandler(SubscribeStatusToContext evt) {
		
		string key := evt.subscribe.serviceID;
		integer cId := evt.instanceContext.getId();
		
		// manage statusToContextCtr
		if not statusToContextCtr.hasKey(key) {
			dictionary <integer, integer> entry := {cId:0};
			statusToContextCtr.add(key, entry);
		}
		else {
			if not statusToContextCtr[key].hasKey(cId) {
				statusToContextCtr[key].add(cId, 0);
				
			}
		}
		statusToContextCtr[key][cId] := statusToContextCtr[key][cId] + 1;
		
		// manage eventRouter
		if not eventRouter.hasKey(key) {
			sequence < context > entry := [];
			eventRouter.add(key, entry);
			addListener(key);
		}
		// look up context in the symbol
		if (eventRouter[key].indexOf(evt.instanceContext) = -1) {
			eventRouter[key].append(evt.instanceContext);
		}

		route evt.subscribe;
	}

	action unsubscribeEventHandler(UnsubscribeStatusToContext evt) {
		string key := evt.unsubscribe.serviceID;
		
		integer cId := evt.instanceContext.getId();
		
		// manage statusToContextCtr
		if ((not statusToContextCtr.hasKey(key)) or 
			(not statusToContextCtr[key].hasKey(cId))) {
			log "unsubscribeEventHandler: unexpected UnsubscribeStatusToContext received for (key=" + 
				key.toString() + ", contextId=" + cId.toString() + ")" at WARN;
		}
		else {
			statusToContextCtr[key][cId] := statusToContextCtr[key][cId] - 1;
			if (statusToContextCtr[key][cId] = 0) {
				statusToContextCtr[key].remove(cId);
				integer i := eventRouter[key].indexOf(evt.instanceContext);
				if (i != -1) {
					eventRouter[key].remove(i);
				}
			}
			if (statusToContextCtr[key].size() = 0) {
				eventRouter.remove(key);
				removeListener(key);
			}
		}

		route evt.unsubscribe;
	}
	
	action addListener(string serviceID) {
		listener dl, el;
		context c;
		Status d;
		dl := on all Status(serviceID=serviceID):d {
			//send d to eventRouter[serviceID];
			for c in eventRouter[serviceID] {
				if c.getId() != context.current().getId() {
					send d to c;
				}
			}			
		}
		if statusListeners.hasKey(serviceID) {
			log "[action addListener] statusListeners already contains a listener for entry " + serviceID at WARN;
		}
		else {
			statusListeners.add(serviceID, dl);
		}
		
		StatusError e;
		el := on all StatusError(serviceID=serviceID):e {
			//send e to eventRouter[serviceID];
			for c in eventRouter[serviceID] {
				if c.getId() != context.current().getId() {
					send e to c;
				}
			}
		}
		if errorListeners.hasKey(serviceID) {
			log "[action addListener] errorListeners already contains a listener for entry " + serviceID at WARN;
		}
		else {
			errorListeners.add(serviceID, el);
		}
	}
	
	action removeListener(string serviceID) {

		if statusListeners.hasKey(serviceID) {
			statusListeners[serviceID].quit();
			statusListeners.remove(serviceID);
		}
		else {
			log "[action removeListener] statusListeners does not contain a listener for entry " + serviceID at WARN;			
		}
		
		if errorListeners.hasKey(serviceID) {
			errorListeners[serviceID].quit();
			errorListeners.remove(serviceID);
		}
		else {
			log "[action removeListener] errorListeners does not contain a listener for entry " + serviceID at WARN;			
		}
	}
}

 0000003d C:\dev\apama_win_full_latest\Apama\monitors\StatusSupport.mon
TIME 0000000c 1568127088,1
MONF 000033e8 /*
 * Apama Correlator-integrated JMS Status Manager service.
 *
 * Implements the StatusSupport event interface to allow an EPL application to 
 * monitor status information about the status of Correlator-Integrated JMS connections, 
 * senders and receivers.
 * 
 * $Copyright (c) 2012 Progress Software Corporation and/or its subsidiaries and affiliates. All rights reserved.$ 
 * $Copyright (c) 2013 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.$ 
 * Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG 
 *
 */
package com.apama.correlator.jms;

using com.apama.correlator.jms.JMSConnectionStatus;
using com.apama.correlator.jms.JMSSenderStatus;
using com.apama.correlator.jms.JMSReceiverStatus;
using com.apama.statusreport.Status;
using com.apama.statusreport.StatusError;
using com.apama.statusreport.SubscribeStatus;
using com.apama.statusreport.UnsubscribeStatus;


/**
 * Provides a bridge between the JMS-specific status events and the generic 
 * StatusSupport API used by some Apama applications. 
 *
 * @see com.apama.statusreport.SubscribeStatus Generic StatusSupport 
 * status subscription request that an application may send to SubscribeStatus.CHANNEL.
 * @see com.apama.statusreport.Status Generic StatusSupport 
 * status information sent to the Status channel by this monitor for subscribed 
 * objects.
 */
monitor CorrelatorJMSStatusManager 
{
	dictionary<SubscribeStatus, integer> subs;

	dictionary<string, JMSConnectionStatusPublisher> csPubs;
	dictionary<string, JMSSenderStatusPublisher> ssPubs;
	dictionary<string, JMSReceiverStatusPublisher> rsPubs;

	action onload() 
	{
		// Set up listeners for client requests
		listenForSubscribeStatus();
		listenForUnsubscribeStatus();
	
		// Set up listeners for correlator-jms status events
		listenForNewJmsEntities();
	}

	action ondie()
	{
		//Can't distinguish between abnormal termination and shutdown,
		//so just log a message to indicate termination.
		log "CORRELATOR_JMS status manager has terminated." at INFO;
	}

	action listenForSubscribeStatus()
	{
		monitor.subscribe(SubscribeStatus.CHANNEL);
		SubscribeStatus newSub;
		on all SubscribeStatus("CORRELATOR_JMS", *, *, *):newSub
		{
			if isValidSubscription(newSub) 
			{
				log "Received status subscription: " + newSub.toString() at INFO;

				if subs.hasKey(newSub) { subs.add(newSub, subs[newSub] + 1); }
				else { subs.add(newSub, 1); }

				boolean atLeastOneAckSent := false;
				
				JMSConnectionStatusPublisher csPub;
				for csPub in csPubs.values()
				{
					atLeastOneAckSent := csPub.ackMatchingNewSub(newSub) or atLeastOneAckSent;
				}

				JMSSenderStatusPublisher ssPub;
				for ssPub in ssPubs.values()
				{
					atLeastOneAckSent := ssPub.ackMatchingNewSub(newSub) or atLeastOneAckSent;
				}

				JMSReceiverStatusPublisher rsPub;
				for rsPub in rsPubs.values()
				{
					atLeastOneAckSent := rsPub.ackMatchingNewSub(newSub) or atLeastOneAckSent;
				}

				if not atLeastOneAckSent 
				{
					log "No status events received yet from entities matching subscription: " + newSub.toString() at INFO;
					sequence<string> summaries := [ "UNKNOWN" ];
					dictionary<string,string> extraParams := {};	
					Status status := Status("CORRELATOR_JMS", newSub.object, newSub.subServiceID, newSub.connection, "No status events received yet from entities matching subscription", summaries, false, extraParams);
					send status to Status.CHANNEL; 
				}
			}
		}
	}

	action listenForUnsubscribeStatus() 
	{
		UnsubscribeStatus unsub;
		on all UnsubscribeStatus("CORRELATOR_JMS", *, *, *):unsub
		{
			if isValidUnsubscription(unsub)
			{
				log "Received status unsubscription: " + unsub.toString() at INFO;
				SubscribeStatus key := SubscribeStatus(unsub.serviceID, unsub.object, unsub.subServiceID, unsub.connection);
	
				if subs.hasKey(key)
				{
					if subs[key] <= 1
					{
						subs.remove(key);	
					}
					else { subs[key] := subs[key] - 1; }
				}
				else
				{
					log "No subscription exists that matches unsubscription: " + unsub.toString() at DEBUG;
				}
			}
		}
	}

	action listenForNewJmsEntities()
	{
		JMSConnectionStatus cs;
		on all JMSConnectionStatus():cs
		{
			if not csPubs.hasKey(cs.connectionId)
			{
				log "Received connection status from new connection: " + cs.toString() at DEBUG;
				JMSConnectionStatusPublisher csPub := new JMSConnectionStatusPublisher;
				csPub.activate(cs, subs);
				csPubs.add(cs.connectionId, csPub);
			}
		}	

		JMSSenderStatus ss;
		on all JMSSenderStatus():ss
		{
			if not ssPubs.hasKey(ss.connectionId + ":" + ss.senderId)
			{
				log "Received sender status from new sender: " + ss.toString() at DEBUG;
				JMSSenderStatusPublisher ssPub := new JMSSenderStatusPublisher;
				ssPub.activate(ss, subs);
				ssPubs.add(ss.connectionId + ":" + ss.senderId, ssPub);
			}
		}	

		JMSReceiverStatus rs;
		on all JMSReceiverStatus():rs
		{
			if not rsPubs.hasKey(rs.connectionId + ":" + rs.receiverId)
			{
				log "Received receiver status from new receiver: " + rs.toString() at DEBUG;
				JMSReceiverStatusPublisher rsPub := new JMSReceiverStatusPublisher;
				rsPub.activate(rs, subs);
				rsPubs.add(rs.connectionId + ":" + rs.receiverId, rsPub);
			}
		}	
	}

	action isValidSubscription(SubscribeStatus sub) returns boolean 
	{ 
		return isValidSubOrUnsub(sub.serviceID, sub.object, sub.subServiceID, sub.connection, "SubscribeStatus", sub.toString()); 
	}	

	action isValidUnsubscription(UnsubscribeStatus unsub) returns boolean 
	{ 
		return isValidSubOrUnsub(unsub.serviceID, unsub.object, unsub.subServiceID, unsub.connection, "UnsubscribeStatus", unsub.toString()); 
	}	

	action isValidSubOrUnsub(string serviceID, string object, string subServiceID, string connection, string requestType, string asString) returns boolean
	{
		string errMsg;
		if serviceID = "CORRELATOR_JMS"
		{
			if object = ""
			{
				if not subServiceID = ""
				{
					errMsg := "Invalid CORRELATOR_JMS " + requestType + " (subServiceID must be \"\" when object is \"\"): " + asString;	
					send StatusError(serviceID, object, subServiceID, connection, errMsg, true) to StatusError.CHANNEL;
					return false;
				}
			}
			else if object = "CONNECTION"
			{
				if connection = ""
				{
					errMsg := "Invalid CORRELATOR_JMS " + requestType + " (connection may not be \"\" when object is \"CONNECTION\"): " + asString;
					send StatusError(serviceID, object, subServiceID, connection, errMsg, true) to StatusError.CHANNEL;
					return false;
				}

				if not subServiceID = ""
				{
					errMsg := "Invalid CORRELATOR_JMS " + requestType + " (subServiceID must be \"\" when object is \"CONNECTION\"): " + asString;	
					send StatusError(serviceID, object, subServiceID, connection, errMsg, true) to StatusError.CHANNEL;
					return false;
				}
			}
			else if object = "SENDER" or object = "RECEIVER"
			{
				if connection = ""
				{
					errMsg := "Invalid CORRELATOR_JMS " + requestType + " (connection may not be \"\" when object is \"" + object + "\"): " + asString;
					send StatusError(serviceID, object, subServiceID, connection, errMsg, true) to StatusError.CHANNEL;
					return false;
				}

				if subServiceID = ""
				{
					errMsg := "Invalid CORRELATOR_JMS " + requestType + " (subServiceID may not be \"\" when object is \"" + object + "\"): " + asString;	
					send StatusError(serviceID, object, subServiceID, connection, errMsg, true) to StatusError.CHANNEL;
					return false;
				}
			}
			else
			{ 
				errMsg := "Invalid CORRELATOR_JMS " + requestType + " (valid values for object field are \"CONNECTION\", \"SENDER\", \"RECEIVER\" or \"\"): " + asString;
				send StatusError(serviceID, object, subServiceID, connection, errMsg, true) to StatusError.CHANNEL;
				return false; 
			} 
			
			return true;
		}
		else 
		{ 
			errMsg := "Unexpected request to validate non-CORRELATOR_JMS " + requestType + " (serviceID must be CORRELATOR_JMS): " + asString;
			send StatusError(serviceID, object, subServiceID, connection, errMsg, true) to StatusError.CHANNEL;
			return false; 
		}
	}

	event JMSConnectionStatusPublisher
	{
		JMSConnectionStatus current;	
		dictionary<SubscribeStatus, integer> allSubs;
		
		action activate(JMSConnectionStatus cs, dictionary<SubscribeStatus, integer> subs) 
		{
			current := cs;
			allSubs := subs;

			if existsMatchingSub() { sendStatus(); }

			JMSConnectionStatus update;
			on all JMSConnectionStatus(current.connectionId, *, *, *):update
			{
				current := update;	
				if existsMatchingSub() { sendStatus(); }	
			}
		}

		action existsMatchingSub() returns boolean 
		{ 
			SubscribeStatus sub;
			for sub in allSubs.keys()
			{
				if matches(sub) { return true; }
			}
			return false;
		}

		action matches(SubscribeStatus sub) returns boolean
		{
			return (sub.object = "" and (sub.connection = "" or sub.connection = current.connectionId)) or 
	 			(sub.object = "CONNECTION" and sub.connection = current.connectionId);
		}

		action ackMatchingNewSub(SubscribeStatus newSub) returns boolean 
		{ 
			if matches(newSub)
			{
				sendStatus();
				return true;
			} 
			return false;
		}

		action sendStatus() 
		{
			boolean available := false;
			if (current.status = JMSConnectionStatus.OK) { available := true; }

			sequence<string> summaries := [ current.status ];
			dictionary<string,string> extraParams := {};	
			Status status := Status("CORRELATOR_JMS", "CONNECTION", "", current.connectionId, current.errorMessage, summaries, available, extraParams);
			send status to Status.CHANNEL;
		}
	}

	event JMSSenderStatusPublisher
	{
		JMSSenderStatus current;	
		dictionary<SubscribeStatus, integer> allSubs;

		action activate(JMSSenderStatus ss, dictionary<SubscribeStatus, integer> subs) 
		{
			current := ss;
			allSubs := subs;

			if existsMatchingSub() { sendStatus(); }

			JMSSenderStatus update;
			on all JMSSenderStatus(current.connectionId, current.senderId, *, *, *, *, *):update
			{	
				current := update;	
				if existsMatchingSub() { sendStatus(); }	
			}
		}

		action existsMatchingSub() returns boolean 
		{ 
			SubscribeStatus sub;
			for sub in allSubs.keys()
			{
				if matches(sub) { return true; }
			}
			return false;
		}

		action matches(SubscribeStatus sub) returns boolean
		{
			return (sub.object = "" and (sub.connection = "" or sub.connection = current.connectionId)) or 
	 			(sub.object = "SENDER" and sub.connection = current.connectionId and sub.subServiceID = current.senderId);
		}

		action ackMatchingNewSub(SubscribeStatus newSub) returns boolean 
		{
			if matches(newSub)
			{
				sendStatus();
				return true;
			} 
			return false;
		}

		action sendStatus() 
		{
			boolean available := false;
			if (current.status = JMSSenderStatus.OK) { available := true; }

			sequence<string> summaries := [ current.status ];
			dictionary<string,string> extraParams := {};	
			Status status := Status("CORRELATOR_JMS", "SENDER", current.senderId, current.connectionId, current.errorMessage, summaries, available, extraParams);
			send status to Status.CHANNEL; 
		}
	}

	event JMSReceiverStatusPublisher
	{
		JMSReceiverStatus current;	
		dictionary<SubscribeStatus, integer> allSubs;

		action activate(JMSReceiverStatus rs, dictionary<SubscribeStatus, integer> subs) 
		{
			current := rs;
			allSubs := subs;

			if existsMatchingSub() { sendStatus(); }
			
			JMSReceiverStatus update;
			on all JMSReceiverStatus(current.connectionId, current.receiverId, *, *, *, *, *, *, *, *, *):update
			{
				current := update;	
				if existsMatchingSub() { sendStatus(); }	
			}
		}

		action existsMatchingSub() returns boolean 
		{ 
			SubscribeStatus sub;
			for sub in allSubs.keys()
			{
				if matches(sub) { return true; }
			}
			return false;
		}

		action matches(SubscribeStatus sub) returns boolean
		{
			return (sub.object = "" and (sub.connection = "" or sub.connection = current.connectionId)) or 
	 			(sub.object = "RECEIVER" and sub.connection = current.connectionId and sub.subServiceID = current.receiverId);
		}

		action ackMatchingNewSub(SubscribeStatus newSub) returns boolean 
		{
			if matches(newSub)
			{
				sendStatus();
				return true;
			} 
			return false;
		}

		action sendStatus() 
		{
			boolean available := false;
			if (current.status = JMSReceiverStatus.OK) { available := true; }
			log "Sending receiver status report in response to status event: " + current.toString() at DEBUG;

			sequence<string> summaries := [ current.status ];
			dictionary<string,string> extraParams := {};	
			Status status := Status("CORRELATOR_JMS", "RECEIVER", current.receiverId, current.connectionId, current.errorMessage, summaries, available, extraParams);
			send status to Status.CHANNEL;
		}
	}
}
 0000004a C:\dev\apama_win_full_latest\Apama\monitors\CorrelatorJMSStatusManager.mon
TIME 0000000e 1568127088.2,1
MONF 00000e49 //*****************************************************************************
// Title:         DashboardSupport.mon
// Description:   Monitor defining events to be sent when a client connects
//                or disconnects from a dashboard.  The monitor also provides
//                multi-context support for the connect/disconnect events.
// Dependencies:  None
// $Copyright(c) 2010 Progress Software Corporation (PSC). All rights reserved.$
// $Copyright (c) 2013-2015 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.$
// Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG
//
//*****************************************************************************

package com.apama.dashboard;


event DashboardClientConnected {
	string userName;
	string sessionId;
	dictionary<string,string> extraParams;
}

event DashboardClientDisconnected {
	string userName;
	string sessionId;
	dictionary<string,string> extraParams;
}

// Events to support parallel execution (contexts)

event RegisterContextForDashboardClientConnections {
	context instanceContext;
}

event DeregisterContextForDashboardClientConnections {
	context instanceContext;
}


/**
 * This monitor provides the context forwarders needed to allow
 * the Dashboard connect and disconnect notification events to be sent to
 * the registered contexts.
 * The notifications are always sent to the main context.
 */
monitor DashboardSupport
{
	// Used to persist contexts interested in notifications
	sequence < context > notifyContexts;

	action onload() {
		
		log "Loaded Dashboard Client Connect Notification service" at INFO;
		
		// Forwarders to support parallel execution (contexts)
		setupContextForwarders();
		
	}
	
	action setupContextForwarders()
	{

		DashboardClientConnected connect;
		on all DashboardClientConnected(): connect {
			log "Dashboard Client Connected - User:" + connect.userName +
				"  Session:" + connect.sessionId at DEBUG;
			if notifyContexts.size() > 0 {
				context ctx;
				for ctx in notifyContexts {
					send connect to ctx;
				}
			}
		}

		DashboardClientDisconnected disconnect;
		on all DashboardClientDisconnected(): disconnect {
			log "Dashboard Client Disconnected - User:" + disconnect.userName +
				"  Session:" + disconnect.sessionId at DEBUG;
			if notifyContexts.size() > 0 {
				context ctx;
				for ctx in notifyContexts {
					send disconnect to ctx;
				}
			}
		}
		
		RegisterContextForDashboardClientConnections regCtx;
		on all RegisterContextForDashboardClientConnections():regCtx registerCtx(regCtx.instanceContext);
	
		DeregisterContextForDashboardClientConnections deregCtx;
		on all DeregisterContextForDashboardClientConnections():deregCtx deregisterCtx(deregCtx.instanceContext);
	}
	
	action registerCtx(context ctx)
	{		
		notifyContexts.append(ctx);
	}

	action deregisterCtx(context ctx)
	{
		if notifyContexts.size() > 0 {
			integer ctxId := notifyContexts.indexOf(ctx);
			if ctxId >= 0 {
				notifyContexts.remove(ctxId);
			}
		}
	}

	action ondie() {
		if (notifyContexts.size() != 0) {
			log "ondie: Dashboard Support service is terminating but there may still be contexts subscribed to dashboard connect events" at ERROR;
		}
		else {
			log "ondie: Dashboard Support service is terminating" at INFO;
		}
	}

	action onunload() {
		log "Unloaded Dashboard Support service" at INFO;
	}


}
 00000040 C:\dev\apama_win_full_latest\Apama\monitors\DashboardSupport.mon
